.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Action::Serialize 3"
.TH Catalyst::Action::Serialize 3 "2014-10-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Action::Serialize \- Serialize Data in a Response
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package Foo::Controller::Bar;
\&
\&    _\|_PACKAGE_\|_\->config(
\&        \*(Aqdefault\*(Aq   => \*(Aqtext/x\-yaml\*(Aq,
\&        \*(Aqstash_key\*(Aq => \*(Aqrest\*(Aq,
\&        \*(Aqmap\*(Aq       => {
\&            \*(Aqtext/html\*(Aq          => [ \*(AqView\*(Aq, \*(AqTT\*(Aq, ],
\&            \*(Aqtext/x\-yaml\*(Aq        => \*(AqYAML\*(Aq,
\&            \*(Aqtext/x\-data\-dumper\*(Aq => [ \*(AqData::Serializer\*(Aq, \*(AqData::Dumper\*(Aq ],
\&        }
\&    );
\&
\&    sub end :ActionClass(\*(AqSerialize\*(Aq) {}
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This action will serialize the body of an \s-1HTTP\s0 Response.  The serializer is
selected by introspecting the \s-1HTTP\s0 Requests content-type header.
.PP
It requires that your Catalyst controller is properly configured to set up the
mapping between Content Type's and Serialization classes.
.PP
The specifics of serializing each content-type is implemented as a plugin to
Catalyst::Action::Serialize.
.PP
Typically, you would use this ActionClass on your \f(CW\*(C`end\*(C'\fR method.  However,
nothing is stopping you from choosing specific methods to Serialize:
.PP
.Vb 3
\&  sub foo :Local :ActionClass(\*(AqSerialize\*(Aq) {
\&     .. populate stash with data ..
\&  }
.Ve
.PP
When you use this module, the request class will be changed to
Catalyst::Request::REST.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.SS "map"
.IX Subsection "map"
Takes a hashref, mapping Content-Types to a given serializer plugin.
.SS "default"
.IX Subsection "default"
This is the 'fall\-back' Content-Type if none of the requested or acceptable
types is found in the \*(L"map\*(R". It must be an entry in the \*(L"map\*(R".
.SS "stash_key"
.IX Subsection "stash_key"
Specifies the key of the stash entry holding the data that is to be serialized.
So if the value is \*(L"rest\*(R", we will serialize the data under:
.PP
.Vb 1
\&  $c\->stash\->{\*(Aqrest\*(Aq}
.Ve
.SS "content_type_stash_key"
.IX Subsection "content_type_stash_key"
Specifies the key of the stash entry that optionally holds an overriding
Content-Type. If set, and if the specified stash entry has a valid value,
then it takes priority over the requested content types.
.PP
This can be useful if you want to dynamically force a particular content type,
perhaps for debugging.
.SH "HELPFUL PEOPLE"
.IX Header "HELPFUL PEOPLE"
Daisuke Maki pointed out that early versions of this Action did not play
well with others, or generally behave in a way that was very consistent
with the rest of Catalyst.
.SH "CUSTOM ERRORS"
.IX Header "CUSTOM ERRORS"
For building custom error responses when serialization fails, you can create
an ActionRole (and use Catalyst::Controller::ActionRole to apply it to the
\&\f(CW\*(C`end\*(C'\fR action) which overrides \f(CW\*(C`unsupported_media_type\*(C'\fR and/or \f(CW\*(C`_serialize_bad_request\*(C'\fR
methods.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
You likely want to look at Catalyst::Controller::REST, which implements
a sensible set of defaults for doing a \s-1REST\s0 controller.
.PP
Catalyst::Action::Deserialize, Catalyst::Action::REST
.SH "AUTHORS"
.IX Header "AUTHORS"
See Catalyst::Action::REST for authors.
.SH "LICENSE"
.IX Header "LICENSE"
You may distribute this code under the same terms as Perl itself.
