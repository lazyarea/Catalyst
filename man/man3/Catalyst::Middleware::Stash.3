.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Middleware::Stash 3"
.TH Catalyst::Middleware::Stash 3 "2014-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "TITLE"
.IX Header "TITLE"
Catalyst::Middleware::Stash \- The Catalyst stash \- in middleware
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
We've moved the Catalyst stash to middleware.  Please don't use this
directly since it is likely to move off the Catalyst namespace into a stand
alone distribution
.PP
We store a coderef under the \f(CW\*(C`PSGI_KEY\*(C'\fR which can be dereferenced with
key values or nothing to access the underly hashref.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
This class defines the following subroutines.
.SS "\s-1PSGI_KEY\s0"
.IX Subsection "PSGI_KEY"
Returns the hash key where we store the stash.  You should not assume
the string value here will never change!  Also, its better to use
\&\*(L"get_stash\*(R" or \*(L"stash\*(R".
.SS "get_stash"
.IX Subsection "get_stash"
Expect: \f(CW$psgi_env\fR.
.PP
Exportable subroutine.
.PP
Get the stash out of the \f(CW$env\fR.
.SS "stash"
.IX Subsection "stash"
Expects: An object that does \f(CW\*(C`env\*(C'\fR and arguments
.PP
Exportable subroutine.
.PP
Given an object with a method \f(CW\*(C`env\*(C'\fR get or set stash values, either
as a method or via hashref modification.  This stash is automatically
reset for each request (it is not persistent or shared across connected
clients.  Stash key / value are stored in memory.
.PP
.Vb 2
\&    use Plack::Request;
\&    use Catalyst::Middleware::Stash \*(Aqstash\*(Aq;
\&
\&    my $app = sub {
\&      my $env = shift;
\&      my $req = Plack::Request\->new($env);
\&      my $stashed = $req\->stash\->{in_the_stash};  # Assume the stash was previously populated.
\&
\&      return [200, [\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq],
\&        ["I found $stashed in the stash!"]];
\&    };
.Ve
.PP
If the stash does not yet exist, we initialize one and return that.
.SH "METHODS"
.IX Header "METHODS"
This class defines the following methods.
.SS "call"
.IX Subsection "call"
Used by plack to call the middleware
