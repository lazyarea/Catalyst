.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "SQL::Translator::Producer::Oracle 3"
.TH SQL::Translator::Producer::Oracle 3 "2014-08-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Translator::Producer::Oracle \- Oracle SQL producer
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::Translator;
\&
\&  my $t = SQL::Translator\->new( parser => \*(Aq...\*(Aq, producer => \*(AqOracle\*(Aq );
\&  print $translator\->translate( $file );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Creates an \s-1SQL\s0 \s-1DDL\s0 suitable for Oracle.
.SH "producer_args"
.IX Header "producer_args"
.IP "delay_constraints" 4
.IX Item "delay_constraints"
This option remove the primary key and other key constraints from the
\&\s-1CREATE\s0 \s-1TABLE\s0 statement and adds \s-1ALTER\s0 TABLEs at the end with it.
.IP "quote_field_names" 4
.IX Item "quote_field_names"
Controls whether quotes are being used around column names in generated \s-1DDL\s0.
.IP "quote_table_names" 4
.IX Item "quote_table_names"
Controls whether quotes are being used around table, sequence and trigger names in
generated \s-1DDL\s0.
.SH "NOTES"
.IX Header "NOTES"
.SS "Autoincremental primary keys"
.IX Subsection "Autoincremental primary keys"
This producer uses sequences and triggers to autoincrement primary key
columns, if necessary. SQLPlus and \s-1DBI\s0 expect a slightly different syntax
of \s-1CREATE\s0 \s-1TRIGGER\s0 statement. You might have noticed that this
producer returns a scalar containing all statements concatenated by
newlines or an array of single statements depending on the context
(scalar, array) it has been called in.
.PP
SQLPlus expects following trigger syntax:
.PP
.Vb 11
\&    CREATE OR REPLACE TRIGGER ai_person_id
\&    BEFORE INSERT ON person
\&    FOR EACH ROW WHEN (
\&     new.id IS NULL OR new.id = 0
\&    )
\&    BEGIN
\&     SELECT sq_person_id.nextval
\&     INTO :new.id
\&     FROM dual;
\&    END;
\&    /
.Ve
.PP
Whereas if you want to create the same trigger using \*(L"do\*(R" in \s-1DBI\s0, you need
to omit the last slash:
.PP
.Vb 10
\&    my $dbh = DBI\->connect(\*(Aqdbi:Oracle:mysid\*(Aq, \*(Aqscott\*(Aq, \*(Aqtiger\*(Aq);
\&    $dbh\->do("
\&        CREATE OR REPLACE TRIGGER ai_person_id
\&        BEFORE INSERT ON person
\&        FOR EACH ROW WHEN (
\&         new.id IS NULL OR new.id = 0
\&        )
\&        BEGIN
\&         SELECT sq_person_id.nextval
\&         INTO :new.id
\&         FROM dual;
\&        END;
\&    ");
.Ve
.PP
If you call this producer in array context, we expect you want to process
the returned array of statements using \s-1DBI\s0 like
\&\*(L"deploy\*(R" in DBIx::Class::Schema does.
.PP
To get this working we removed the slash in those statements in version
0.09002 of SQL::Translator when called in array context. In scalar
context the slash will be still there to ensure compatibility with SQLPlus.
.SH "CREDITS"
.IX Header "CREDITS"
Mad props to Tim Bunce for much of the logic stolen from his \*(L"mysql2ora\*(R"
script.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ken Youens-Clark <kclark@cpan.org>,
Alexander Hartmaier <abraxxa@cpan.org>,
Fabien Wernli <faxmodem@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
SQL::Translator, DDL::Oracle, mysql2ora.
