.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Utils 3"
.TH Catalyst::Utils 3 "2014-10-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Utils \- The Catalyst Utils
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Catalyst.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Catalyst Utilities.
.SH "METHODS"
.IX Header "METHODS"
.SS "appprefix($class)"
.IX Subsection "appprefix($class)"
.Vb 1
\&    MyApp::Foo becomes myapp_foo
.Ve
.SS "class2appclass($class);"
.IX Subsection "class2appclass($class);"
.Vb 2
\&    MyApp::Controller::Foo::Bar becomes MyApp
\&    My::App::Controller::Foo::Bar becomes My::App
.Ve
.SS "class2classprefix($class);"
.IX Subsection "class2classprefix($class);"
.Vb 2
\&    MyApp::Controller::Foo::Bar becomes MyApp::Controller
\&    My::App::Controller::Foo::Bar becomes My::App::Controller
.Ve
.SS "class2classsuffix($class);"
.IX Subsection "class2classsuffix($class);"
.Vb 1
\&    MyApp::Controller::Foo::Bar becomes Controller::Foo::Bar
.Ve
.SS "class2env($class);"
.IX Subsection "class2env($class);"
Returns the environment name for class.
.PP
.Vb 2
\&    MyApp becomes MYAPP
\&    My::App becomes MY_APP
.Ve
.ie n .SS "class2prefix( $class, $case );"
.el .SS "class2prefix( \f(CW$class\fP, \f(CW$case\fP );"
.IX Subsection "class2prefix( $class, $case );"
Returns the uri prefix for a class. If case is false the prefix is converted to lowercase.
.PP
.Vb 1
\&    My::App::Controller::Foo::Bar becomes foo/bar
.Ve
.ie n .SS "class2tempdir( $class [, $create ] );"
.el .SS "class2tempdir( \f(CW$class\fP [, \f(CW$create\fP ] );"
.IX Subsection "class2tempdir( $class [, $create ] );"
Returns a tempdir for a class. If create is true it will try to create the path.
.PP
.Vb 2
\&    My::App becomes /tmp/my/app
\&    My::App::Controller::Foo::Bar becomes /tmp/my/app/c/foo/bar
.Ve
.SS "home($class)"
.IX Subsection "home($class)"
Returns home directory for given class.
.SS "dist_indicator_file_list"
.IX Subsection "dist_indicator_file_list"
Returns a list of files which can be tested to check if you're inside
a \s-1CPAN\s0 distribution which is not yet installed.
.PP
These are:
.IP "Makefile.PL" 4
.IX Item "Makefile.PL"
.PD 0
.IP "Build.PL" 4
.IX Item "Build.PL"
.IP "dist.ini" 4
.IX Item "dist.ini"
.IP "cpanfile" 4
.IX Item "cpanfile"
.PD
.ie n .SS "prefix($class, $name);"
.el .SS "prefix($class, \f(CW$name\fP);"
.IX Subsection "prefix($class, $name);"
Returns a prefixed action.
.PP
.Vb 1
\&    MyApp::Controller::Foo::Bar, yada becomes foo/bar/yada
.Ve
.SS "request($uri)"
.IX Subsection "request($uri)"
Returns an HTTP::Request object for a uri.
.SS "ensure_class_loaded($class_name, \e%opts)"
.IX Subsection "ensure_class_loaded($class_name, %opts)"
Loads the class unless it already has been loaded.
.PP
If \f(CW$opts\fR{ignore_loaded} is true always tries the require whether the package
already exists or not. Only pass this if you're either (a) sure you know the
file exists on disk or (b) have code to catch the file not found exception
that will result if it doesn't.
.ie n .SS "merge_hashes($hashref, $hashref)"
.el .SS "merge_hashes($hashref, \f(CW$hashref\fP)"
.IX Subsection "merge_hashes($hashref, $hashref)"
Base code to recursively merge two hashes together with right-hand precedence.
.ie n .SS "env_value($class, $key)"
.el .SS "env_value($class, \f(CW$key\fP)"
.IX Subsection "env_value($class, $key)"
Checks for and returns an environment value. For instance, if \f(CW$key\fR is
\&'home', then this method will check for and return the first value it finds,
looking at \f(CW$ENV\fR{\s-1MYAPP_HOME\s0} and \f(CW$ENV\fR{\s-1CATALYST_HOME\s0}.
.SS "term_width"
.IX Subsection "term_width"
Try to guess terminal width to use with formatting of debug output
.PP
All you need to get this work, is:
.PP
1) Install Term::Size::Any, or
.PP
2) Export \f(CW$COLUMNS\fR from your shell.
.PP
(Warning to bash users: 'echo \f(CW$COLUMNS\fR' may be showing you the bash
variable, not \f(CW$ENV\fR{\s-1COLUMNS\s0}. 'export COLUMNS=$COLUMNS' and you should see
that 'env' now lists \s-1COLUMNS\s0.)
.PP
As last resort, default value of 80 chars will be used.
.PP
Calling \f(CW\*(C`term_width\*(C'\fR with a true value will cause it to be recalculated; you
can use this to cause it to get recalculated when your terminal is resized like
this
.PP
.Vb 1
\& $SIG{WINCH} = sub { Catalyst::Utils::term_width(1) };
.Ve
.SS "resolve_namespace"
.IX Subsection "resolve_namespace"
Method which adds the namespace for plugins and actions.
.PP
.Vb 1
\&  _\|_PACKAGE_\|_\->setup(qw(MyPlugin));
\&
\&  # will load Catalyst::Plugin::MyPlugin
.Ve
.SS "build_middleware (@args)"
.IX Subsection "build_middleware (@args)"
Internal application that converts a single middleware definition (see
\&\*(L"psgi_middleware\*(R" in Catalyst) into an actual instance of middleware.
.SS "apply_registered_middleware ($psgi)"
.IX Subsection "apply_registered_middleware ($psgi)"
Given a \f(CW$psgi\fR reference, wrap all the \*(L"registered_middlewares\*(R" in Catalyst
around it and return the wrapped version.
.PP
This exists to deal with the fact Catalyst registered middleware can be
either an object with a wrap method or a coderef.
.SH "PSGI Helpers"
.IX Header "PSGI Helpers"
Utility functions to make it easier to work with \s-1PSGI\s0 applications under Catalyst
.SS "env_at_path_prefix"
.IX Subsection "env_at_path_prefix"
Localize \f(CW$env\fR under the current controller path prefix:
.PP
.Vb 1
\&    package MyApp::Controller::User;
\&
\&    use Catalyst::Utils;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub name :Local {
\&      my ($self, $c) = @_;
\&      my $env = $c\->Catalyst::Utils::env_at_path_prefix;
\&    }
.Ve
.PP
Assuming you have a request like \s-1GET\s0 /user/name:
.PP
In the example case \f(CW$env\fR will have \s-1PATH_INFO\s0 of '/name' instead of
\&'/user/name' and \s-1SCRIPT_NAME\s0 will now be '/user'.
.SS "env_at_action"
.IX Subsection "env_at_action"
Localize \f(CW$env\fR under the current action namespace.
.PP
.Vb 1
\&    package MyApp::Controller::User;
\&
\&    use Catalyst::Utils;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub name :Local {
\&      my ($self, $c) = @_;
\&      my $env = $c\->Catalyst::Utils::env_at_action;
\&    }
.Ve
.PP
Assuming you have a request like \s-1GET\s0 /user/name:
.PP
In the example case \f(CW$env\fR will have \s-1PATH_INFO\s0 of '/' instead of
\&'/user/name' and \s-1SCRIPT_NAME\s0 will now be '/user/name'.
.PP
Alternatively, assuming you have a request like \s-1GET\s0 /user/name/foo:
.PP
In this example case \f(CW$env\fR will have \s-1PATH_INFO\s0 of '/foo' instead of
\&'/user/name/foo' and \s-1SCRIPT_NAME\s0 will now be '/user/name'.
.PP
This is probably a common case where you want to mount a \s-1PSGI\s0 application
under an action but let the Args fall through to the \s-1PSGI\s0 app.
.SS "env_at_request_uri"
.IX Subsection "env_at_request_uri"
Localize \f(CW$env\fR under the current request \s-1URI:\s0
.PP
.Vb 1
\&    package MyApp::Controller::User;
\&
\&    use Catalyst::Utils;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&
\&    sub name :Local Args(1) {
\&      my ($self, $c, $id) = @_;
\&      my $env = $c\->Catalyst::Utils::env_at_request_uri
\&    }
.Ve
.PP
Assuming you have a request like \s-1GET\s0 /user/name/hello:
.PP
In the example case \f(CW$env\fR will have \s-1PATH_INFO\s0 of '/' instead of
\&'/user/name' and \s-1SCRIPT_NAME\s0 will now be '/user/name/hello'.
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
