.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Response 3"
.TH Catalyst::Response 3 "2014-11-14" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Response \- stores output responding to the current client request
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    $res = $c\->response;
\&    $res\->body;
\&    $res\->code;
\&    $res\->content_encoding;
\&    $res\->content_length;
\&    $res\->content_type;
\&    $res\->cookies;
\&    $res\->header;
\&    $res\->headers;
\&    $res\->output;
\&    $res\->redirect;
\&    $res\->status;
\&    $res\->write;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the Catalyst Response class, which provides methods for responding to
the current client request. The appropriate Catalyst::Engine for your environment
will turn the Catalyst::Response into a \s-1HTTP\s0 Response and return it to the client.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$res\->body( $text | $fh | $iohandle_object )"
.el .SS "\f(CW$res\fP\->body( \f(CW$text\fP | \f(CW$fh\fP | \f(CW$iohandle_object\fP )"
.IX Subsection "$res->body( $text | $fh | $iohandle_object )"
.Vb 1
\&    $c\->response\->body(\*(AqCatalyst rocks!\*(Aq);
.Ve
.PP
Sets or returns the output (text or binary data). If you are returning a large body,
you might want to use a IO::Handle type of object (Something that implements the read method
in the same fashion), or a filehandle \s-1GLOB\s0. Catalyst
will write it piece by piece into the response.
.PP
When using a IO::Handle type of object and no content length has been
already set in the response headers Catalyst will make a reasonable attempt
to determine the size of the Handle. Depending on the implementation of your
handle object, setting the content length may fail. If it is at all possible
for you to determine the content length of your handle object, 
it is recommended that you set the content length in the response headers
yourself, which will be respected and sent by Catalyst in the response.
.PP
Please note that the object needs to implement \f(CW\*(C`getline\*(C'\fR, not just
\&\f(CW\*(C`read\*(C'\fR.
.PP
Starting from version 5.90060, when using an IO::Handle object, you
may want to use Plack::Middleware::XSendfile, to delegate the
actual serving to the frontend server. To do so, you need to pass to
\&\f(CW\*(C`body\*(C'\fR an \s-1IO\s0 object with a \f(CW\*(C`path\*(C'\fR method. This can be achieved in
two ways.
.PP
Either using Plack::Util:
.PP
.Vb 2
\&  my $fh = IO::File\->new($file, \*(Aqr\*(Aq);
\&  Plack::Util::set_io_path($fh, $file);
.Ve
.PP
Or using IO::File::WithPath
.PP
.Vb 1
\&  my $fh = IO::File::WithPath\->new($file, \*(Aqr\*(Aq);
.Ve
.PP
And then passing the filehandle to body and setting headers, if needed.
.PP
.Vb 4
\&  $c\->response\->body($fh);
\&  $c\->response\->headers\->content_type(\*(Aqtext/plain\*(Aq);
\&  $c\->response\->headers\->content_length(\-s $file);
\&  $c\->response\->headers\->last_modified((stat($file))[9]);
.Ve
.PP
Plack::Middleware::XSendfile can be loaded in the application so:
.PP
.Vb 6
\& _\|_PACKAGE_\|_\->config(
\&     psgi_middleware => [
\&         \*(AqXSendfile\*(Aq,
\&         # other middlewares here...
\&        ],
\& );
.Ve
.PP
\&\fBBeware\fR that loading the middleware without configuring the
webserver to set the request header \f(CW\*(C`X\-Sendfile\-Type\*(C'\fR to a supported
type (\f(CW\*(C`X\-Accel\-Redirect\*(C'\fR for nginx, \f(CW\*(C`X\-Sendfile\*(C'\fR for Apache and
Lighttpd), could lead to the disclosure of private paths to malicious
clients setting that header.
.PP
Nginx needs the additional X\-Accel-Mapping header to be set in the
webserver configuration, so the middleware will replace the absolute
path of the \s-1IO\s0 object with the internal nginx path. This is also
useful to prevent a buggy app to server random files from the
filesystem, as it's an internal redirect.
.PP
An nginx configuration for FastCGI could look so:
.PP
.Vb 10
\& server {
\&     server_name example.com;
\&     root /my/app/root;
\&     location /private/repo/ {
\&         internal;
\&         alias /my/app/repo/;
\&     }
\&     location /private/staging/ {
\&         internal;
\&         alias /my/app/staging/;
\&     }
\&     location @proxy {
\&         include /etc/nginx/fastcgi_params;
\&         fastcgi_param SCRIPT_NAME \*(Aq\*(Aq;
\&         fastcgi_param PATH_INFO   $fastcgi_script_name;
\&         fastcgi_param HTTP_X_SENDFILE_TYPE X\-Accel\-Redirect;
\&         fastcgi_param HTTP_X_ACCEL_MAPPING /my/app=/private;
\&         fastcgi_pass  unix:/my/app/run/app.sock;
\&    }
\& }
.Ve
.PP
In the example above, passing filehandles with a local path matching
/my/app/staging or /my/app/repo will be served by nginx. Passing paths
with other locations will lead to an internal server error.
.PP
Setting the body to a filehandle without the \f(CW\*(C`path\*(C'\fR method bypasses
the middleware completely.
.PP
For Apache and Lighttpd, the mapping doesn't apply and setting the
X\-Sendfile-Type is enough.
.ie n .SS "$res\->has_body"
.el .SS "\f(CW$res\fP\->has_body"
.IX Subsection "$res->has_body"
Predicate which returns true when a body has been set.
.ie n .SS "$res\->code"
.el .SS "\f(CW$res\fP\->code"
.IX Subsection "$res->code"
Alias for \f(CW$res\fR\->status.
.ie n .SS "$res\->content_encoding"
.el .SS "\f(CW$res\fP\->content_encoding"
.IX Subsection "$res->content_encoding"
Shortcut for \f(CW$res\fR\->headers\->content_encoding.
.ie n .SS "$res\->content_length"
.el .SS "\f(CW$res\fP\->content_length"
.IX Subsection "$res->content_length"
Shortcut for \f(CW$res\fR\->headers\->content_length.
.ie n .SS "$res\->content_type"
.el .SS "\f(CW$res\fP\->content_type"
.IX Subsection "$res->content_type"
Shortcut for \f(CW$res\fR\->headers\->content_type.
.PP
This value is typically set by your view or plugin. For example,
Catalyst::Plugin::Static::Simple will guess the mime type based on the file
it found, while Catalyst::View::TT defaults to \f(CW\*(C`text/html\*(C'\fR.
.ie n .SS "$res\->cookies"
.el .SS "\f(CW$res\fP\->cookies"
.IX Subsection "$res->cookies"
Returns a reference to a hash containing cookies to be set. The keys of the
hash are the cookies' names, and their corresponding values are hash
references used to construct a CGI::Simple::Cookie object.
.PP
.Vb 1
\&    $c\->response\->cookies\->{foo} = { value => \*(Aq123\*(Aq };
.Ve
.PP
The keys of the hash reference on the right correspond to the CGI::Simple::Cookie
parameters of the same name, except they are used without a leading dash.
Possible parameters are:
.IP "value" 4
.IX Item "value"
.PD 0
.IP "expires" 4
.IX Item "expires"
.IP "domain" 4
.IX Item "domain"
.IP "path" 4
.IX Item "path"
.IP "secure" 4
.IX Item "secure"
.IP "httponly" 4
.IX Item "httponly"
.PD
.ie n .SS "$res\->header"
.el .SS "\f(CW$res\fP\->header"
.IX Subsection "$res->header"
Shortcut for \f(CW$res\fR\->headers\->header.
.ie n .SS "$res\->headers"
.el .SS "\f(CW$res\fP\->headers"
.IX Subsection "$res->headers"
Returns an HTTP::Headers object, which can be used to set headers.
.PP
.Vb 1
\&    $c\->response\->headers\->header( \*(AqX\-Catalyst\*(Aq => $Catalyst::VERSION );
.Ve
.ie n .SS "$res\->output"
.el .SS "\f(CW$res\fP\->output"
.IX Subsection "$res->output"
Alias for \f(CW$res\fR\->body.
.ie n .SS "$res\->redirect( $url, $status )"
.el .SS "\f(CW$res\fP\->redirect( \f(CW$url\fP, \f(CW$status\fP )"
.IX Subsection "$res->redirect( $url, $status )"
Causes the response to redirect to the specified \s-1URL\s0. The default status is
\&\f(CW302\fR.
.PP
.Vb 2
\&    $c\->response\->redirect( \*(Aqhttp://slashdot.org\*(Aq );
\&    $c\->response\->redirect( \*(Aqhttp://slashdot.org\*(Aq, 307 );
.Ve
.PP
This is a convenience method that sets the Location header to the
redirect destination, and then sets the response status.  You will
want to \f(CW\*(C` return \*(C'\fR or \f(CW\*(C`$c\->detach()\*(C'\fR to interrupt the normal
processing flow if you want the redirect to occur straight away.
.PP
\&\fBNote:\fR do not give a relative \s-1URL\s0 as \f(CW$url\fR, i.e: one that is not fully
qualified (= \f(CW\*(C`http://...\*(C'\fR, etc.) or that starts with a slash
(= \f(CW\*(C`/path/here\*(C'\fR). While it may work, it is not guaranteed to do the right
thing and is not a standard behaviour. You may opt to use \fIuri_for()\fR or
\&\fIuri_for_action()\fR instead.
.ie n .SS "$res\->location"
.el .SS "\f(CW$res\fP\->location"
.IX Subsection "$res->location"
Sets or returns the \s-1HTTP\s0 'Location'.
.ie n .SS "$res\->status"
.el .SS "\f(CW$res\fP\->status"
.IX Subsection "$res->status"
Sets or returns the \s-1HTTP\s0 status.
.PP
.Vb 1
\&    $c\->response\->status(404);
.Ve
.PP
\&\f(CW$res\fR\->code is an alias for this, to match HTTP::Response\->code.
.ie n .SS "$res\->write( $data )"
.el .SS "\f(CW$res\fP\->write( \f(CW$data\fP )"
.IX Subsection "$res->write( $data )"
Writes \f(CW$data\fR to the output stream.
.ie n .SS "$res\->write_fh"
.el .SS "\f(CW$res\fP\->write_fh"
.IX Subsection "$res->write_fh"
Returns a \s-1PSGI\s0 \f(CW$writer\fR object that has two methods, write and close.  You can
close over this object for asynchronous and nonblocking applications.  For
example (assuming you are using a supporting server, like Twiggy
.PP
.Vb 1
\&    package AsyncExample::Controller::Root;
\&
\&    use Moose;
\&
\&    BEGIN { extends \*(AqCatalyst::Controller\*(Aq }
\&
\&    sub prepare_cb {
\&      my $write_fh = pop;
\&      return sub {
\&        my $message = shift;
\&        $write_fh\->write("Finishing: $message\en");
\&        $write_fh\->close;
\&      };
\&    }
\&
\&    sub anyevent :Local :Args(0) {
\&      my ($self, $c) = @_;
\&      my $cb = $self\->prepare_cb($c\->res\->write_fh);
\&
\&      my $watcher;
\&      $watcher = AnyEvent\->timer(
\&        after => 5,
\&        cb => sub {
\&          $cb\->(scalar localtime);
\&          undef $watcher; # cancel circular\-ref
\&        });
\&    }
.Ve
.ie n .SS "$res\->print( @data )"
.el .SS "\f(CW$res\fP\->print( \f(CW@data\fP )"
.IX Subsection "$res->print( @data )"
Prints \f(CW@data\fR to the output stream, separated by $,.  This lets you pass
the response object to functions that want to write to an IO::Handle.
.ie n .SS "$self\->finalize_headers($c)"
.el .SS "\f(CW$self\fP\->finalize_headers($c)"
.IX Subsection "$self->finalize_headers($c)"
Writes headers to response if not already written
.SS "from_psgi_response"
.IX Subsection "from_psgi_response"
Given a \s-1PSGI\s0 response (either three element \s-1ARRAY\s0 reference \s-1OR\s0 coderef expecting
a \f(CW$responder\fR) set the response from it.
.PP
Properly supports streaming and delayed response and / or async \s-1IO\s0 if running
under an expected event loop.
.PP
Example:
.PP
.Vb 1
\&    package MyApp::Web::Controller::Test;
\&
\&    use base \*(AqCatalyst::Controller\*(Aq;
\&    use Plack::App::Directory;
\&
\&
\&    my $app = Plack::App::Directory\->new({ root => "/path/to/htdocs" })
\&      \->to_app;
\&
\&    sub myaction :Local Args {
\&      my ($self, $c) = @_;
\&      $c\->res\->from_psgi_response($app\->($c\->req\->env));
\&    }
.Ve
.PP
Please note this does not attempt to map or nest your \s-1PSGI\s0 application under
the Controller and Action namespace or path.
.SS "\s-1DEMOLISH\s0"
.IX Subsection "DEMOLISH"
Ensures that the response is flushed and closed at the end of the
request.
.SS "meta"
.IX Subsection "meta"
Provided by Moose
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
