.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Manual::Intro 3"
.TH HTML::FormHandler::Manual::Intro 3 "2014-08-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Manual::Intro \- introduction to using FormHandler
.SH "VERSION"
.IX Header "VERSION"
version 0.40057
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Manual Index
.PP
HTML::FormHandler is a form handling package that validates \s-1HTML\s0 form data
and, for database forms, saves it to the database on validation.
It has field classes that match various data types and \s-1HTML\s0 form elements,
and rendering roles that can be used to render forms in many
different ways, from hand-built forms to totally automated rendering.
It can, of course, be used to validate data even if you are not interested
in the rendering capabilities.
.PP
A FormHandler 'form' is a Perl subclass of HTML::FormHandler for non-database forms,
or a subclass of HTML::FormHandler::Model::DBIC for database forms, and in
it you define your fields and validation routines. Because it's a Perl class
written in Moose, you have a lot of flexibility and control.
.PP
You can validate with Perl methods or Moose type constraints; you can use
your own validation libraries. You can define your own field classes that
perform specialized validation.
.PP
When the form is validated, you can get the validated values back with
\&\f(CW\*(C`$form\->value\*(C'\fR.
.PP
A working example of a Catalyst app using FormHandler forms is available
on github at https://github.com/gshank/formhandler\-example <https://github.com/gshank/formhandler-example>.
.SH "Basics"
.IX Header "Basics"
.SS "Create a form class"
.IX Subsection "Create a form class"
The most common way of using FormHandler is to create a form package. You
must 'use' \*(L"HTML::FormHandler::Moose\*(R" and 'extend' FormHandler:
.PP
.Vb 3
\&    package MyApp::Form::Sample;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
.Ve
.PP
Then you add some fields with 'has_field', and a field 'type' (the short
name of the field package). (Fields with no type have type 'Text'.)
.PP
.Vb 2
\&    has_field \*(Aqfoo\*(Aq;
\&    has_field \*(Aqbar\*(Aq => ( type => \*(AqSelect\*(Aq );
.Ve
.PP
Basic field types are Text, Select, Checkbox, Submit, Hidden, Reset,
TextArea, Password, Upload. See HTML::FormHandler::Manual::Fields for
more information.
.SS "Or create a form class dynamically"
.IX Subsection "Or create a form class dynamically"
You can also create a form class 'dynamically', by creating a 'new'
HTML::FormHandler object. Use a 'field_list' parameter to create the fields
instead of 'has_field'.
.PP
.Vb 5
\&    my $form = HTML::FormHandler\->new( field_list => [
\&            \*(Aqusername\*(Aq => { type => \*(AqText\*(Aq },
\&            \*(Aqselections\*(Aq => { type => \*(AqSelect\*(Aq },
\&        ]
\&    );
.Ve
.PP
Some features will not be available using this method (like the automatic
use of 'validate_<field_name>' methods) and it's not as easy to test,
of course.
.SS "Process the form"
.IX Subsection "Process the form"
The form's 'process' method should be run on each request, passing in the
request parameters:
.PP
.Vb 3
\&    $form\->process( params => $c\->request\->body_parameters,
\&        action => $action,
\&    );
.Ve
.PP
If the parameters are not empty, then validation will be performed. The
corollary is that you should not pass in extra parameters when the form
has not been posted. A special 'posted' flag can be used if
the form consists entirely of fields like checkboxes that do not include
names in params if unchecked, and also works to prevent validation from
being performed if there are extra params:
.PP
.Vb 2
\&    $form\->process( posted => ( $c\->req\->method eq \*(AqPOST\*(Aq ),
\&        params => $c\->request\->parameters, action => $action );
.Ve
.PP
There is an alternative method for processing the form, which is sometimes
preferred for persistent forms. It returns a 'result' object, and clears
the form:
.PP
.Vb 1
\&    my $result = $form\->run( params => $c\->request\->body_parameters );
.Ve
.PP
You can also set most other FormHandler attributes on the 'process' call.,
One useful feature is that you can activate or inactivate fields:
.PP
.Vb 1
\&    $form\->process( params => $params, active => [\*(Aqfield1\*(Aq, \*(Aqfield2\*(Aq] );
.Ve
.PP
See also HTML::FormHandler.
.SS "Or process a database form"
.IX Subsection "Or process a database form"
A database form inherits from HTML::FormHandler::Model::DBIC instead of
HTML::FormHandler. You must either pass in the \s-1DBIC\s0 row object or give
FormHandler information to retrieve the row object.
.PP
.Vb 4
\&    $form\->process( item => $row, params => $params );
\&    \-\- or \-\-
\&    $form\->process( item_id => $id, schema => $schema,
\&        item_class => \*(AqMyRow\*(Aq, params => $params );
.Ve
.PP
\&'item_class' is often set in the form class.
.PP
See also HTML::FormHandler::Manual::Database and
HTML::FormHandler::TraitFor::Model::DBIC.
.SS "After processing the form"
.IX Subsection "After processing the form"
A database form will have saved the data or created a new row, so often no
more processing is necessary. You can get the structured field values from
\&\f(CW\*(C`$form\->value\*(C'\fR, and do whatever you want with them.
.PP
If the validation succeeded, you may want to redirect:
.PP
.Vb 6
\&    $form\->process( params => $params );
\&    return unless $form\->validated
\&    $c\->res\->redirect( .... );
\&    \-\- or \-\-
\&    return unless $form\->process( params => params );
\&    $c\->res\->redirect;
.Ve
.SS "Rendering the form"
.IX Subsection "Rendering the form"
At its simplest, all you need to do is \f(CW\*(C`$form\->render\*(C'\fR in a
template.
.PP
.Vb 1
\&    [% form.render %]
.Ve
.PP
The automatic rendering is powerful and flexible \*(-- you can do almost
anything with the right settings. Or you can render the form with a
template.
.PP
The form object will give you a hashref of values suitable for
filling in the form with \f(CW\*(C`$form\->fif\*(C'\fR.
.PP
By default FormHandler structures fields (and renders them) in a way
that matches the database. If you want to organize the rendering output
in different ways, you can use blocks to organize your fields.
.PP
.Vb 1
\&   has_block \*(Aqfieldset1\*(Aq => ( render_list => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq] );
.Ve
.PP
For more rendering info, see HTML::FormHandler::Manual::Rendering.
.SS "Defaults for form fields"
.IX Subsection "Defaults for form fields"
The simplest way to provide defaults is by setting the default attribute
in a field definition:
.PP
.Vb 1
\&   has_field \*(Aqmy_foo\*(Aq => ( default => \*(Aqmy_foo\*(Aq );
.Ve
.PP
The database row ('item') that is passed in will provide initial values
for the form, of course. You can also provide default values with an
\&'init_object', which acts kind of like a database object:
.PP
.Vb 1
\&   $form\->process( init_object => { foo => \*(Aq...\*(Aq, bar => \*(Aq...\*(Aq } );
.Ve
.PP
There are a number of other flags and methods for providing defaults.
See HTML::FormHandler::Manual::Defaults.
.SS "Validation"
.IX Subsection "Validation"
You can validate a field with a method in the form 'validate_<field_name>':
.PP
.Vb 7
\&    has_field \*(Aqfoo\*(Aq;
\&    sub validate_foo {
\&        my ( $self, $field ) = @_; # self is the form
\&        unless( $field\->value == .... ) {
\&            $field\->add_error( .... );
\&        }
\&    }
.Ve
.PP
You can provide a validation coderef that will be a field method:
.PP
.Vb 7
\&    has_field \*(Aqfoo\*(Aq => ( validate_method => \e&check_foo );
\&    sub check_foo {
\&        my $self = shift; # self is field
\&        unless( $self\->value == ... ) {
\&            $self\->add_error( ... );
\&        }
\&    }
.Ve
.PP
You can use 'apply' to use Moose types for validation, from HTML::FormHandler::Types
or another Moose type collection:
.PP
.Vb 3
\&    use HTML::FormHandler::Types (\*(AqNotAllDigits\*(Aq);
\&    ...
\&    has_field \*(Aqmy_field\*(Aq => ( apply => [NotAllDigits] );
.Ve
.PP
Or create validators with check:
.PP
.Vb 2
\&    has_field \*(Aqquux\*(Aq => (
\&        apply => [ { check => qr/abc/, message => \*(AqNot a valid quux\*(Aq } ] );
.Ve
.PP
Or use a validate coderef:
.PP
.Vb 7
\&    has_field \*(Aqfoo\*(Aq => ( validate_method => \e&check_foo );
\&    sub check_foo {
\&        my $self = shift;
\&        if ( $self\->value =~ s/..../ ) {
\&            $self\->add_error(\*(Aq....\*(Aq);
\&        }
\&    }
.Ve
.PP
You can also create custom fields with custom validation, or use an
existing field that does the validation you need.
.PP
See HTML::FormHandler::Manual::Validation for more information on
validation or HTML::FormHandler::Manual::Fields for more information
on fields.
.SS "Organizing your form code"
.IX Subsection "Organizing your form code"
You can use 'has_field' and 'has_block' in Moose roles:
.PP
.Vb 2
\&    package MyApp::Form::Role::Address;
\&    use HTML::FormHandler::Moose::Role;
\&
\&    has_field \*(Aqfoo\*(Aq;
\&    has_block \*(Aqbar\*(Aq;
.Ve
.PP
Your forms can inherit from base classes that set common application
defaults. You can override field definitions with '+'.
.PP
You can create 'compound' fields and include them in a form:
.PP
.Vb 10
\&    package MyApp::Form::Field::Complex;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler::Field::Compound\*(Aq;
\&    has_field \*(Aqfield1\*(Aq => ( validate_method => \e&validate_field1 );
\&    has_field \*(Aqfield2\*(Aq => ( type => \*(AqSelect\*(Aq,
\&        options_method => \e&options_field2 );
\&    sub validate_field1 { ... }
\&    sub options_field2 { ... }
\&    ...
\&    package MyApp::Form::Complex;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&    has \*(Aq+field_name_space\*(Aq => ( sub => {[\*(AqMyApp::Form::Field\*(Aq]} );
\&    has_field \*(Aqcompound1\*(Aq => ( type => \*(AqComplex\*(Aq );
\&    has_field \*(Aqcompound2\*(Aq => ( type => \*(AqComplex\*(Aq );
.Ve
.SS "Testing"
.IX Subsection "Testing"
It's much easier to write unit tests for FormHandler forms than for
Catalyst controllers. The 't' directory of the downloaded distribution
has lots of examples. See HTML::FormHandler::Manual::Testing for more
information.
.SH "Localization"
.IX Header "Localization"
FormHandler's built-in errors are added to the form fields with
\&\f(CW\*(C`$field\->add_error\*(C'\fR, and to the form with \f(CW\*(C`$form\->add_form_error\*(C'\fR.
These methods call a \f(CW\*(C`$self\->_localize\*(C'\fR method which is a coderef set from
the field's default_localize sub, the field's 'localize_meth' attribute with
\&\f(CW\*(C`localize_meth => sub {}\*(C'\fR, or a form's sub localize_meth. The default localize
uses Locale::Maketext.  You can also use duck_type classes for localization.
See the documentation in HTML::FormHandler::TraitFor::I18N and the tests in xt/locale.t.
.PP
If you wish to skip localization for a particular message (such as for system errors)
you can use \f(CW\*(C`$field\->push_errors\*(C'\fR or \f(CW\*(C`$form\->push_form_errors\*(C'\fR.
.PP
See also HTML::FormHandler::TraitFor::I18N.
.SH "Performance"
.IX Header "Performance"
FormHandler makes heavy use of Moose, so almost all of FormHandler's profiled time
will actually be in Moose methods, mostly constructing form and field attributes.
Some people prefer to use a persistent form class (in a Moose attribute) in order
to skip the form building step on each call. Other people don't like that solution
because state will remain in the form until the next process call. The 'clear'
method is called at the beginning of each 'process', but additional Moose attributes
in the form, etc, will have to cleared by the programmer.
.PP
If you are loading options from the database and you don't need to have them refreshed
each time, you can set the 'do_not_reload' flag in the Select/Multiple field.
If you're not using the field widget roles, you can set the 'no_widgets' flag.
If you always use 'process' on each call (recommended) then you can set the
\&'no_preload' flag in the form to skip building results in \s-1BUILD\s0 (new).
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
