.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Authentication::Realm::Progressive 3"
.TH Catalyst::Authentication::Realm::Progressive 3 "2012-06-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Authentication::Realm::Progressive \- Authenticate against multiple realms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This Realm allows an application to use a single \fIauthenticate()\fR call during
which multiple realms are used and tried incrementally until one performs
a successful authentication is accomplished.
.PP
A simple use case is a Temporary Password that looks and acts exactly as a
regular password. Without changing the authentication code, you can
authenticate against multiple realms.
.PP
Another use might be to support a legacy website authentication system, trying
the current auth system first, and upon failure, attempting authentication against
the legacy system.
.SS "\s-1EXAMPLE\s0"
.IX Subsection "EXAMPLE"
If your application has multiple realms to authenticate, such as a temporary
password realm and a normal realm, you can configure the progressive realm as
the default, and configure it to iteratively call the temporary realm and then
the normal realm.
.PP
.Vb 10
\& _\|_PACKAGE_\|_\->config(
\&    \*(AqPlugin::Authentication\*(Aq => {
\&        default_realm => \*(Aqprogressive\*(Aq,
\&        realms => {
\&            progressive => {
\&                class => \*(AqProgressive\*(Aq,
\&                realms => [ \*(Aqtemp\*(Aq, \*(Aqnormal\*(Aq ],
\&                # Modify the authinfo passed into authenticate by merging
\&                # these hashes into the realm\*(Aqs authenticate call:
\&                authinfo_munge => {
\&                    normal => { \*(Aqtype\*(Aq => \*(Aqnormal\*(Aq },
\&                    temp   => { \*(Aqtype\*(Aq => \*(Aqtemporary\*(Aq },
\&                }
\&            },
\&            normal => {
\&                credential => {
\&                    class => \*(AqPassword\*(Aq,
\&                    password_field => \*(Aqsecret\*(Aq,
\&                    password_type  => \*(Aqhashed\*(Aq,
\&                    password_hash_type => \*(AqSHA\-1\*(Aq,
\&                },
\&                store => {
\&                    class      => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqSchema::Person::Identity\*(Aq,
\&                    id_field   => \*(Aqid\*(Aq,
\&                }
\&            },
\&            temp => {
\&                credential => {
\&                    class => \*(AqPassword\*(Aq,
\&                    password_field => \*(Aqsecret\*(Aq,
\&                    password_type  => \*(Aqhashed\*(Aq,
\&                    password_hash_type => \*(AqSHA\-1\*(Aq,
\&                },
\&                store => {
\&                    class    => \*(AqDBIx::Class\*(Aq,
\&                    user_model => \*(AqSchema::Person::Identity\*(Aq,
\&                    id_field   => \*(Aqid\*(Aq,
\&                }
\&            },
\&        }
\&    }
\& );
.Ve
.PP
Then, in your controller code, to attempt authentication against both realms
you just have to do a simple authenticate call:
.PP
.Vb 5
\& if ( $c\->authenticate({ id => $username, password => $password }) ) {
\&     if ( $c\->user\->type eq \*(Aqtemporary\*(Aq ) {
\&         # Force user to change password
\&     }
\& }
.Ve
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
.IP "realms" 4
.IX Item "realms"
An array reference consisting of each realm to attempt authentication against,
in the order listed.  If the realm does not exist, calling authenticate will
die.
.IP "authinfo_munge" 4
.IX Item "authinfo_munge"
A hash reference keyed by realm names, with values being hash references to
merge into the authinfo call that is subsequently passed into the realm's
authenticate method.  This is useful if your store uses the same class for each
realm, separated by some other token (in the \s-1EXAMPLE\s0 authinfo_mungesection,
the 'realm' is a column on \f(CW\*(C`Schema::Person::Identity\*(C'\fR that will be either
\&'temp' or 'local', to ensure the query to fetch the user finds the right
Identity record for that realm.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new ($realmname, $config, $app)"
.el .SS "new ($realmname, \f(CW$config\fP, \f(CW$app\fP)"
.IX Subsection "new ($realmname, $config, $app)"
Constructs an instance of this realm.
.SS "authenticate"
.IX Subsection "authenticate"
This method iteratively calls each realm listed in the \f(CW\*(C`realms\*(C'\fR configuration
key.  It returns after the first successful authentication call is done.
.SH "AUTHORS"
.IX Header "AUTHORS"
J. Shirley \f(CW\*(C`<jshirley@cpan.org>\*(C'\fR
.PP
Jay Kuri \f(CW\*(C`<jayk@cpan.org>\*(C'\fR
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2008 the aforementioned authors. All rights reserved. This program
is free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
