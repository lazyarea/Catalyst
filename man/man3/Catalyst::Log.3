.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Log 3"
.TH Catalyst::Log 3 "2014-10-25" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Log \- Catalyst Log Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    $log = $c\->log;
\&    $log\->debug($message);
\&    $log\->info($message);
\&    $log\->warn($message);
\&    $log\->error($message);
\&    $log\->fatal($message);
\&
\&    if ( $log\->is_debug ) {
\&         # expensive debugging
\&    }
.Ve
.PP
See Catalyst.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the default, simple logging functionality for Catalyst.
If you want something different set \f(CW\*(C`$c\->log\*(C'\fR in your application module,
e.g.:
.PP
.Vb 1
\&    $c\->log( MyLogger\->new );
.Ve
.PP
Your logging object is expected to provide the interface described here.
Good alternatives to consider are Log::Log4Perl and Log::Dispatch.
.PP
If you want to be able to log arbitrary warnings, you can do something along
the lines of
.PP
.Vb 1
\&    $SIG{_\|_WARN_\|_} = sub { MyApp\->log\->warn(@_); };
.Ve
.PP
however this is (a) global, (b) hairy and (c) may have unexpected side effects.
Don't say we didn't warn you.
.SH "LOG LEVELS"
.IX Header "LOG LEVELS"
.SS "debug"
.IX Subsection "debug"
.Vb 2
\&    $log\->is_debug;
\&    $log\->debug($message);
.Ve
.SS "info"
.IX Subsection "info"
.Vb 2
\&    $log\->is_info;
\&    $log\->info($message);
.Ve
.SS "warn"
.IX Subsection "warn"
.Vb 2
\&    $log\->is_warn;
\&    $log\->warn($message);
.Ve
.SS "error"
.IX Subsection "error"
.Vb 2
\&    $log\->is_error;
\&    $log\->error($message);
.Ve
.SS "fatal"
.IX Subsection "fatal"
.Vb 2
\&    $log\->is_fatal;
\&    $log\->fatal($message);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Constructor. Defaults to enable all levels unless levels are provided in
arguments.
.PP
.Vb 2
\&    $log = Catalyst::Log\->new;
\&    $log = Catalyst::Log\->new( \*(Aqwarn\*(Aq, \*(Aqerror\*(Aq );
.Ve
.SS "level"
.IX Subsection "level"
Contains a bitmask of the currently set log levels.
.SS "levels"
.IX Subsection "levels"
Set log levels
.PP
.Vb 1
\&    $log\->levels( \*(Aqwarn\*(Aq, \*(Aqerror\*(Aq, \*(Aqfatal\*(Aq );
.Ve
.SS "enable"
.IX Subsection "enable"
Enable log levels
.PP
.Vb 1
\&    $log\->enable( \*(Aqwarn\*(Aq, \*(Aqerror\*(Aq );
.Ve
.SS "disable"
.IX Subsection "disable"
Disable log levels
.PP
.Vb 1
\&    $log\->disable( \*(Aqwarn\*(Aq, \*(Aqerror\*(Aq );
.Ve
.SS "is_debug"
.IX Subsection "is_debug"
.SS "is_error"
.IX Subsection "is_error"
.SS "is_fatal"
.IX Subsection "is_fatal"
.SS "is_info"
.IX Subsection "is_info"
.SS "is_warn"
.IX Subsection "is_warn"
Is the log level active?
.SS "abort"
.IX Subsection "abort"
Should Catalyst emit logs for this request? Will be reset at the end of
each request.
.PP
*NOTE* This method is not compatible with other log apis, so if you plan
to use Log4Perl or another logger, you should call it like this:
.PP
.Vb 1
\&    $c\->log\->abort(1) if $c\->log\->can(\*(Aqabort\*(Aq);
.Ve
.SS "autoflush"
.IX Subsection "autoflush"
When enabled (default), messages are written to the log immediately instead 
of queued until the end of the request.
.PP
This option, as well as \f(CW\*(C`abort\*(C'\fR, is provided for modules such as 
Catalyst::Plugin::Static::Simple to be able to programmatically 
suppress the output of log messages. By turning off \f(CW\*(C`autoflush\*(C'\fR (application-wide
setting) and then setting the \f(CW\*(C`abort\*(C'\fR flag within a given request, all log 
messages for the given request will be suppressed. \f(CW\*(C`abort\*(C'\fR can still be set
independently of turning off \f(CW\*(C`autoflush\*(C'\fR, however. It just means any messages 
sent to the log up until that point in the request will obviously still be emitted, 
since \f(CW\*(C`autoflush\*(C'\fR means they are written in real-time.
.PP
If you need to turn off autoflush you should do it like this (in your main app 
class):
.PP
.Vb 4
\&    after setup_finalize => sub {
\&      my $c = shift;
\&      $c\->log\->autoflush(0) if $c\->log\->can(\*(Aqautoflush\*(Aq);
\&    };
.Ve
.SS "_send_to_log"
.IX Subsection "_send_to_log"
.Vb 1
\& $log\->_send_to_log( @messages );
.Ve
.PP
This protected method is what actually sends the log information to \s-1STDERR\s0.
You may subclass this module and override this method to get finer control
over the log output.
.ie n .SS "psgienv $env"
.el .SS "psgienv \f(CW$env\fP"
.IX Subsection "psgienv $env"
.Vb 1
\&    $log\->psgienv($env);
.Ve
.PP
\&\s-1NOTE:\s0 This is not meant for public consumption.
.PP
Set the \s-1PSGI\s0 environment for this request. This ensures logs will be sent to
the right place. If the environment has a \f(CW\*(C`psgix.logger\*(C'\fR, it will be used. If
not, we will send logs to \f(CW\*(C`psgi.errors\*(C'\fR if that exists. As a last fallback, we
will send to \s-1STDERR\s0 as before.
.SS "clear_psgi"
.IX Subsection "clear_psgi"
Clears the \s-1PSGI\s0 environment attributes set by \*(L"psgienv\*(R".
.SS "meta"
.IX Subsection "meta"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Catalyst.
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.
