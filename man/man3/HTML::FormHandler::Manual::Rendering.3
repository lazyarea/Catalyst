.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "HTML::FormHandler::Manual::Rendering 3"
.TH HTML::FormHandler::Manual::Rendering 3 "2014-08-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::FormHandler::Manual::Rendering \- how to render with FormHandler
.SH "VERSION"
.IX Header "VERSION"
version 0.40057
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Manual Index
.PP
Rendering can be done in many different ways, from forms rendered entirely in
templates with no information from FormHandler (except possibly the fill-in-the-form
values) to forms that are completely rendered by FormHandler.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
For most situations, something in between hand-built and completely generated
will probably be the best solution. For admin forms that don't need a lot of
styling or special \s-1HTML\s0, FormHandler's automatic rendering may be appropriate.
FormHandler rendering may also be a good solution if you have enough forms that
putting time into creating rendering widgets and themes is worthwhile.
.PP
The automatic rendering is also useful when developing a new form. You can
get an idea of what it looks like, and then customize it.
.PP
Another situation in which FormHandler rendering may be useful is when
the form is complex enough that working in Perl is a better idea than
putting lots of logic into templates.
.PP
All of the rendering is designed to be easily replaced with elements of your
own, or to be replaced entirely. You can create your own rendering 'widgets'
and load them into the fields by designating the directory in the
\&'widget_name_space'. You could also create a completely separate renderer
that's a separate object or class that takes a form object,
or a role that is applied to your form.
.PP
Note that unless you set 'no_widgets' in the form, the rendering roles are
automatically applied. You don't need to include anything else, unless you
want to use a different renderer.
.SS "Mostly templates"
.IX Subsection "Mostly templates"
The names of your fields must match the names of your FormHandler fields.
If you use compound fields, you must use the FormHandler naming convention.
.PP
Form used in examples:
.PP
.Vb 3
\&    package MyApp::Form::Example;
\&    use HTML::FormHandler::Moose;
\&    extends \*(AqHTML::FormHandler\*(Aq;
\&
\&    has_field \*(Aqfoo\*(Aq;
\&    has_field \*(Aqbar\*(Aq;
\&    has_field \*(Aqsave\*(Aq => ( type => \*(AqSubmit\*(Aq );
.Ve
.PP
If you have existing forms in templates or just prefer them, you can use
the 'fill\-in\-form' values provided with the form's 'fif' function.
.PP
.Vb 11
\&    my $form = MyApp::Form::Example\->new;
\&    $form\->process( params => $params );
\&    $c\->stash( fif => $form\->fif );
\&    ...
\&    <form id="myform" action="/edit/example" method="post">
\&    <label>Foo</label>
\&    <input id="foo" name="foo" value="[% fif.foo %]">
\&    <label>Bar</label>
\&    <input id="bar" name="bar" value="[% fif.bar %]">
\&    <input type="submit" name="submit" value="Save">
\&    </form>
.Ve
.PP
If you are looking for an easy way to get your fields to line up in an evenly spaced manner,
all uniformly aligned, and to do so without using templates or tables, you can externally style the
default FormHandler output with the following \s-1CSS\s0 rule (not supported in internet explorer 6).
.PP
*\fIThis above is useful for simple forms.  Complex forms with fieldsets and other extra features\fR
*\fIwill require further styling of the \s-1HTML\s0.  The following rule is also \s-1HTML\s0 5 compatible.\fR
.PP
.Vb 5
\&   form#id_of_your_form div div label, form#id_of_your_form div div input {
\&      float: left;
\&      display: inline\-block;
\&      width: 40%
\&   } /* make sure the parent element is sized appropriately.  700px is a good width */
.Ve
.PP
Going a little bit farther in using FormHandler rendering, you can render
each of the fields individually:
.PP
.Vb 7
\&     <form id="myform" action="/edit/example" method="post">
\&     <fieldset><legend>My Foo</legend>
\&     [% form.field(\*(Aqfoo\*(Aq).render %]
\&     </fieldset>
\&     [% form.field(\*(Aqbar\*(Aq).render %]
\&     [% form.field(\*(Aqsave\*(Aq).render %]
\&     </form>
.Ve
.PP
If you don't want the wrappers, use a widget_wrapper of 'None'.
.PP
.Vb 1
\&    has \*(Aq+widget_wrapper\*(Aq => ( default => \*(AqNone\*(Aq );
.Ve
.PP
Then you can provide the \s-1HTML\s0 in which the form elements are
embedded:
.PP
.Vb 6
\&    <div class="my_class">
\&    [% form.field(\*(Aqfoo\*(Aq).render %]
\&    </div>
\&    <div class="another_class">
\&    [% form.field(\*(Aqbar\*(Aq).render %]
\&    </div>
.Ve
.PP
You can also use the 'render_element' method, if you want to leave the
wrapper in place, but sometimes render 'bare' html elements:
.PP
.Vb 3
\&    <div class="my_class">
\&    [% form.field(\*(Aqfoo\*(Aq).render_element %]
\&    </div>
.Ve
.PP
If you wish to loop through the fields yourself, use the 'sorted_fields'
method, since it skips inactive fields and handles the 'order' attribute.
.PP
A set of Template Toolkit templates is also provided in the 'share'
directory. There are individual templates for each 'widget', such as
a checkbox, and there is also an all-in-one template that includes
blocks for the various 'widgets'. If you want to use these templates
you can just copy them to your template directory and specify the form
template in your controller.
.PP
See also HTML::FormHandler::Manual::Templates.
.SS "Automatic rendering"
.IX Subsection "Automatic rendering"
If you take all the defaults, you can simply render a form with \f(CW\*(C`$form\->render\*(C'\fR.
.PP
.Vb 1
\&    [% form.render %]
.Ve
.PP
This uses the HTML::FormHandler::Widget::Form::Simple role, which is applied to
the form by default. You can use a different form rendering role by including
it using 'with':
.PP
.Vb 2
\&    with \*(AqHTML::FormHandler::Widget::Form::Table\*(Aq;
\&    has \*(Aq+widget_wrapper\*(Aq => ( default => \*(AqTable\*(Aq );
.Ve
.PP
For the 'Table' form widget, you will also need to set the matching
Table widget_wrapper.
.PP
A widget role, providing the 'render' method, and a widget wrapper role,
providing the 'wrap_field' method, are applied to each field when the form is built.
Each field has a default widget, but you can change that by setting 'widget' to a different
widget role:
.PP
.Vb 1
\&    has_field \*(Aqfoxy\*(Aq => ( widget => \*(AqMyWidget\*(Aq, widget_wrapper => \*(AqMyWrapper\*(Aq );
.Ve
.PP
Often if you need custom rendering what you need to provide is a custom widget_wrapper.
The 'widgets' render only the input elements, and that often doesn't need to be
changed. If you have standard \s-1HTML\s0 that is used when rendering forms, making custom
widget_wrappers is often the way to go.
.PP
Default widget roles are found in the HTML::FormHandler::Widget directory, in the
\&'Field', 'Form', and 'Wrapper subdirectories.
The name space used to look for the widget roles can be specified on a form or
field basis by setting 'widget_name_space' to an arrayref of name spaces:
.PP
.Vb 1
\&   has \*(Aq+widget_name_space\*(Aq => ( default => sub { [\*(AqMyApp::Form::Widget\*(Aq ] } );
.Ve
.PP
For the above widget ('MyWidget') and widget_name_space, you need to have a package named
\&'MyApp::Form::Widget::Field::MyWidget'.
.PP
The HTML::FormHandler::Widget name space is always searched as the last name space.
This means that you can set up an application or form specific set of widgets.
Widgets in a widget directory (specified in widget_name_space) are located in either
a 'Field', 'Wrapper', or 'Form' subdirectory. (Blocks are in a 'Blocks' subdirectory.)
.PP
You can also create an 'all\-in\-one' type rendering role, using
HTML::FormHandler::Render::Simple as a basis. It used the method name
\&'render_field' on the form ( \f(CW\*(C`$form\->render_field(\*(Aqfield_name\*(Aq)\*(C'\fR )
instead of the 'render' method on the field.
.PP
In addition to the 'Simple' wrapper, there is a 'Bootstrap' wrapper which
creates \s-1HTML\s0 formatted to use the Twitter Bootstrap 2.0 \s-1CSS\s0. There's also a sample
\&\*(L"theme\*(R", HTML::FormHandler::Widget::Theme::Bootstrap, which is a role that sets
the widget_wrapper to 'Bootstrap', and provides Bootstrap-type formatting of the
form error message.
.PP
There are a lot of different settings that control the rendering. Some of them are
attributes in the form or field, and some of them are set using the 'tags' hashref
in the field or the 'form_tags' hashref in the form.
.PP
You can make your own copy of an existing wrapper and add features to it.
However, there are so many different ways to render the \s-1HTML\s0 around a field, that it's
very difficult to handle more than a short list of standard presentations in
one 'wrapper'. It may be better to make a number of more atomic widget wrappers and
use those rather than complicate the already fairly complicated \*(L"Simple\*(R" and
\&\*(L"Bootstrap\*(R" wrappers more.
.SS "\s-1HTML\s0 attributes"
.IX Subsection "HTML attributes"
Arbitrary \s-1HTML\s0 attributes on form elements (such as 'input' elements) can be specified
with 'element_attr' on the field. You can also set attributes for the label with
\&'label_attr' and attributes for the wrapper with 'wrapper_attr'. The 'class'
attributes are handled separately, and are arrayrefs (element_class, wrapper_class,
label_class):
.PP
.Vb 1
\&    has_field \*(Aqfoo\*(Aq => ( wrapper_class => [\*(Aqform\*(Aq, \*(Aqspecial\*(Aq ] );
.Ve
.PP
See the documentation on \*(L"Attributes_for_creating_HTML\*(R" in HTML::FormHandler::Field.
.SS "Form settings"
.IX Subsection "Form settings"
.IP "widget_wrapper" 4
.IX Item "widget_wrapper"
The short name of the rendering wrapper widget to be applied to the fields. When
the fields are constructed this is merged into fields that do not already
set a widget wrapper.
.IP "do_form_wrapper" 4
.IX Item "do_form_wrapper"
Flag set with 'sub build_do_form_wrapper{ 1 }'. Default is no form wrapper.
.IP "form_tags" 4
.IX Item "form_tags"
Hashref of various tags used in rendering code. See the documentation
for HTML::FormHandler::Widget::Form::Simple.
.IP "form_element_attr" 4
.IX Item "form_element_attr"
Hashref of arbitrary \s-1HTML\s0 attributes to be included in the form element.
.Sp
.Vb 1
\&   sub build_form_element_attr { [ ... ] }
.Ve
.IP "form_element_class" 4
.IX Item "form_element_class"
Arrayref of classes to be included in the form element.
.Sp
.Vb 3
\&   form_element_class => [\*(Aqhfh\*(Aq, \*(Aqadmin\*(Aq]
\&   \-\- or in your class \-\-
\&   sub build_form_element_class { [\*(Aqhfh\*(Aq, \*(Aqadmin\*(Aq] }
.Ve
.Sp
The above class would produce a form element:
.Sp
.Vb 1
\&   <form id="myform" method="post" class="hfh admin">
.Ve
.IP "form_wrapper_attr" 4
.IX Item "form_wrapper_attr"
Hashref of arbitrary \s-1HTML\s0 attributes to be included in the form wrapper
.Sp
.Vb 1
\&   sub build_form_wrapper_attr { { name => \*(Aqformname\*(Aq } }
.Ve
.SS "Form messages"
.IX Subsection "Form messages"
Some messages are rendered at the top of the form (inside the form tag)
by the 'render_form_messages' method, which is implemented in
HTML::FormHandler::Widget::Form::Simple and
HTML::FormHandler::Widget::Theme::BootstrapFormMessages (which is
included by the Bootstrap theme).
.PP
There are three types of form messages: 'error_message', 'success_message',
and 'info_message'. The 'error_message' and 'success_message' are set inside
the form:
.PP
.Vb 2
\&    has \*(Aq+success_message\*(Aq => ( default => \*(AqForm successfully submitted\*(Aq );
\&    has \*(Aq+error_message\*(Aq => ( default => \*(AqThere were errors in your form.\*(Aq );
.Ve
.PP
And then are displayed after the form is validated.
.PP
The 'info_message' is cleared out when a form is re-processed, and so would
normally be set on the process call, or between new & process.
.PP
.Vb 1
\&    $form\->process( params => {}, info_message => \*(AqFill in the form\*(Aq );
.Ve
.SS "Field settings"
.IX Subsection "Field settings"
.Vb 4
\&    has_field \*(Aqfoo\*(Aq => ( widget => \*(AqMyWidget\*(Aq, widget_wrapper => \*(AqSpecialWrapper\*(Aq,
\&        element_attr => { placeholder => \*(Aqenter a foo\*(Aq }, element_class => \*(Aqimportant\*(Aq,
\&        wrapper_class => [\*(Aqlabel\*(Aq], label_class => [\*(Aqmajor\*(Aq],
\&        tags => { wrapper_tag => \*(Aqfieldset\*(Aq } );
.Ve
.IP "widget" 4
.IX Item "widget"
Short name of the rendering widget for this field.
.IP "widget_wrapper" 4
.IX Item "widget_wrapper"
Short name of the wrapping widget for this field.
.IP "do_wrapper" 4
.IX Item "do_wrapper"
Flag that indicates whether or not the 'wrapper' should be rendered.
.IP "do_label" 4
.IX Item "do_label"
Flag that indicates whether or not a label should be rendered.
.IP "element_attr" 4
.IX Item "element_attr"
Hashref of arbitrary \s-1HTML\s0 attributes to include in the element. Note that
this does not include the 'id' and 'type' attributes, which are handled
separately. The 'id' can be changed with the field's 'id' attribute.
.IP "element_class" 4
.IX Item "element_class"
Arrayref of classes to include in the element.
.IP "wrapper_attr" 4
.IX Item "wrapper_attr"
Hashref of arbitrary \s-1HTML\s0 attributes to include in the wrapper.
.IP "wrapper_class" 4
.IX Item "wrapper_class"
Arrayref of classes to include in the wrapper.
.IP "label_attr" 4
.IX Item "label_attr"
Hashref of arbitrary \s-1HTML\s0 attributes to include in the label.
.IP "label_class" 4
.IX Item "label_class"
Arrayref of classes to include in the label.
.IP "build_id_method" 4
.IX Item "build_id_method"
Coderef to construct the 'id'. Useful if your javascript needs a different
format for the 'id'.
.IP "build_label_method" 4
.IX Item "build_label_method"
Coderef to construct the label.
.IP "wrap_label_method" 4
.IX Item "wrap_label_method"
Coderef to wrap the label. Used by the Simple and Bootstrap wrappers.
Useful if your label contains \s-1HTML\s0 or a link. You must do your own
localization and filtering if you use a 'wrap_label' method.
.SS "html_attributes callback"
.IX Subsection "html_attributes callback"
The form has an 'html_attributes' callback which can be used to customize,
localize, or modify the various attributes when used.
Types: element, wrapper, label, form_element, form_wrapper, checkbox_label
.PP
.Vb 8
\&   sub html_attributes {
\&       my ( $self, $obj, $type, $attrs, $result ) = @_;
\&       # obj is either form or field
\&       $attrs\->{class} = \*(Aqlabel\*(Aq if $type eq \*(Aqlabel\*(Aq;
\&       $attrs\->{placeholder} = $self\->_localize($attrs\->{placeholder})
\&           if exists $attrs\->{placeholder};
\&       return $attrs;
\&   }
.Ve
.PP
This callback is called in the methods that wrap the various '_attr' attributes,
i.e. element_attributes, label_attributes, wrapper_attributes,
form_element_attributes, form_wrapper_attributes.
.SS "Field tags"
.IX Subsection "Field tags"
The 'tags' are settings and strings which may vary by the particular widget
that implements them. The best place to look for documentation on them
is in the field widget, field wrapper, and form widgets that you are using.
The 'tags' allow customizing rendering behavior on a per-field basis.
FormHandler has a number of flags/settings that it uses; you can add your
own for your custom rendering code.
.PP
.Vb 3
\&    wrapper_tag    \-\- the tag to use in the wrapper, default \*(Aqdiv\*(Aq
\&    label_tag      \-\- tag to use for label (default \*(Aqlabel\*(Aq)
\&    label_after    \-\- string to append to label, for example \*(Aq: \*(Aq to append a colon
.Ve
.PP
Tags can be used to switch the Simple
wrapper from divs to using paragraphs instead, or to add a colon in
label formatting:
.PP
.Vb 2
\&   has_field \*(Aqmy_field\*(Aq => (
\&       tags => {wrapper_tag => \*(Aqp\*(Aq, label_after => \*(Aq: \*(Aq  } );
.Ve
.PP
Most of the tags are implemented by the 'wrapper' widget, so see that
documentation for more details: HTML::FormHandler::Widget::Wrapper::Simple,
HTML::FormHandler::Widget::Wrapper::Bootstrap.
.PP
\fITag types\fR
.IX Subsection "Tag types"
.PP
The 'get_tag' method will check for these three types of tags and perform
the appropriate action.
.IP "String" 4
.IX Item "String"
Standard, most common type of value for a tag.
.Sp
.Vb 1
\&    has_field \*(Aqbar\*(Aq => ( tags => { before_element => \*(Aq<span>...</span>\*(Aq } );
.Ve
.Sp
Some tags are true/false also:
.Sp
.Vb 2
\&    has_field \*(Aqfoo\*(Aq => ( type => \*(AqCheckBox\*(Aq,
\&        tags => { no_wrapped_label => 1 } );
.Ve
.IP "CodeRef" 4
.IX Item "CodeRef"
You can supply a coderef to a tag, and it will be executed as a method on
the field. This is useful for localization or other sorts of runtime
changes.
.Sp
.Vb 5
\&    has_field \*(Aqbar\*(Aq => ( tags => { before_element => \e&bar_element } );
\&    sub bar_element {
\&        my $self = shift; # $self is the \*(Aqbar\*(Aq field
\&        return \*(Aq<div>In a Sub</div>\*(Aq;
\&    }
.Ve
.IP "Block" 4
.IX Item "Block"
You can supply a block by giving a string that consists of a '%' followed
by the block name:
.Sp
.Vb 3
\&    has_block \*(Aqcomment\*(Aq => ( tag => \*(Aqa\*(Aq, content => \*(AqThis is a comment from a block\*(Aq,
\&        class => [\*(Aqcomment\*(Aq ] );
\&    has_field \*(Aqfoo\*(Aq => ( tags => { before_element => \*(Aq%comment\*(Aq } );
.Ve
.PP
\fITags and other settings for all fields\fR
.IX Subsection "Tags and other settings for all fields"
.PP
Tags can be set for all fields in the form by using a 'build_update_subfields'
sub, or 'widget_tags'. The 'update_subfields' hashref takes general-purpose
keys 'all', 'by_flag' (compound, repeatable, contains), and 'by_type'.
You can also set specific field attributes by using the field name as a key.
For example, if you don't want errors to be displayed
next to the fields, you need to set the 'no_errors' tag:
.PP
.Vb 8
\&   sub build_update_subfields {{
\&       all => { tags => { no_errors => 1 }, wrapper_class => [\*(Aqmyapp\*(Aq] },
\&       by_type => { Text => { element_class => [\*(Aqtext\*(Aq] } },
\&       by_flag => { compound => { do_wrapper => 1 } },
\&       foo => { label => \*(AqMy Foo\*(Aq },
\&   }}
\&   \-\- or \-\-
\&   \*(Aq+widget_tags\*(Aq => ( default => sub { { no_errors => 1 } } );
.Ve
.PP
The 'widget_tags' attribute only handles the 'tags' hashref, so if you also
want to set classes or attributes, then build_update_subfields is more useful.
You can also use 'build_update_subfields' in a custom compound field class.
.PP
If you have defaults that are set in 'build_update_subfields' in a base class,
in order to use hashrefs from both base and current classes, you will need to
merge the hashes:
.PP
.Vb 6
\&    use HTML::FormHandler::Merge (\*(Aqmerge\*(Aq);
\&    sub build_update_subfields {
\&        my $self = shift;
\&        my $new = { all => { tags => { wrapper_tag => \*(Aqp\*(Aq } } };
\&        return merge( $new, $self\->next::method(@_) );
\&    }
.Ve
.PP
In a role you would have to do the equivalent with an 'around' method modifier.
.PP
\fIRepeatable field instances\fR
.IX Subsection "Repeatable field instances"
.PP
The repeatable field instances are constructed internally, so it's trickier to set
things like wrapper tags. There are two ways to do it, using the 'init_contains'
attribute on the repeatable field, and using the 'update_subfields' builder:
.PP
.Vb 5
\&    has_field \*(Aqrecords\*(Aq => ( type => \*(AqRepeatable\*(Aq, num_when_empty => 2,
\&        init_contains => { tags => { wrapper_tag => \*(Aqfieldset\*(Aq } } );
\&    \-\- or \-\-
\&    sub build_update_subfields { { by_flag => {
\&        contains => { tags => { wrapper_tag => \*(Aqfieldset\*(Aq }}}}}
.Ve
.PP
The 'build_update_subfields' option is mainly useful if you have multiple
repeatable fields that you want to set, or if you want defaults in a base
class.
.PP
\fIwidget and widget_wrapper set to 'None'\fR
.IX Subsection "widget and widget_wrapper set to 'None'"
.PP
If you want to implement the 'render' method in a custom field, you can set
\&'widget' to 'None' and no widget will be applied. Setting the 'widget_wrapper'
to 'None' will apply the 'None' wrapper, which simply returns the widget
rendering.
.PP
\fIError messages\fR
.IX Subsection "Error messages"
.PP
The default is currently to display error messages next to the rendered fields,
if you're doing \f(CW\*(C`$form\->render\*(C'\fR. If you don't want messages next to fields,
you can set the 'no_errors' tag, as discussed in the section on 'Tags and other
settings...'.
.PP
Note that the 'None' widget wrapper, since it doesn't render anything except the
form element (input, select, etc), will not render errors next to the field.
Setting the 'do_wrapper' and 'do_label' flags to 0 will still render errors.
.SS "Blocks"
.IX Subsection "Blocks"
When rendering, FormHandler loops through the sorted fields in the form and
executes the 'render' method on each field. Fields in FormHandler forms,
particularly those that interface with a database, are usually structured
in a way that matches the data structure. This doesn't always fit with
the way that you want to display the form.
.PP
\&'Blocks' provide an alternative way of structuring the display. A 'block'
is a fairly basic object that contains a 'render' method. The standard
block class, HTML::FormHandler::Widget::Block, has Moose attributes to
set the \s-1HTML\s0 tag, the label, the classes, etc, plus a 'render_list'
which contains the names of a list of fields or other blocks to render.
.PP
Here is the definition of a fieldset block that contains two fields:
.PP
.Vb 4
\&   has_field \*(Aqfoo\*(Aq;
\&   has_field \*(Aqbar\*(Aq;
\&   has_block \*(Aqfirst_fset\*(Aq => ( tag => \*(Aqfieldset, label => \*(AqTwo Fields\*(Aq,
\&       render_list => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq] );
.Ve
.PP
The 'first_fset' block will render like this:
.PP
.Vb 10
\&    <fieldset><legend>Two Fields</legend>
\&        <div>
\&           <label>Foo</label>
\&           <input type="text" name="foo" id="foo" value="" />
\&        <div>
\&        <div>
\&           <label>Bar</label>
\&           <input type="text" name="bar" id="bar" value="" />
\&        <div>
\&    </fieldset>
.Ve
.PP
In order to actually get this block to be used when you render with
\&\f(CW\*(C`$form\->render\*(C'\fR, you need to supply a 'render_list' on the form
level:
.PP
.Vb 1
\&   sub build_render_list { [\*(Aqfirst_fset\*(Aq, \*(Aqsubmit_btn\*(Aq] }
.Ve
.PP
You could also render it with \f(CW\*(C`$form\->block(\*(Aqfirst_fset\*(Aq)\->render\*(C'\fR.
.PP
Blocks should be located in a widget name space, in a 'Block' directory,
or else the name should be prefixed with a '+'.
.PP
.Vb 2
\&    has \*(Aq+widget_name_space\*(Aq => ( default => sub { [\*(AqMyApp::Form::Widget\*(Aq] };
\&    has_block \*(Aqfirst\*(Aq => ( type => \*(AqMyBlock\*(Aq, ... );
.Ve
.PP
The 'MyBlock' above will be found in 'MyApp::Form::Widget::Block::MyBlock'.
.PP
.Vb 1
\&    has_block \*(Aqintro\*(Aq => ( type => \*(Aq+MyApp::Form::Component::Intro\*(Aq );
.Ve
.PP
A block can inherit from HTML::FormHandler::Widget::Block, but it doesn't
have to. At a minimum it must provide 'new' and 'render' methods. If no
\&'type' is specified, the block is created from the HTML::FormHandler::Widget::Block
package.
.PP
The following package provides a functional block:
.PP
.Vb 10
\&    package MyApp::Component::Section;
\&    sub new {
\&        my ( $class, %args ) = @_;
\&        return bless \e%args, $class;
\&    }
\&    sub form {
\&        my $self = shift;
\&        return $self\->{form};
\&    }
\&    sub render {
\&        return
\&        \*(Aq<div class="intro">
\&          <h3>Please enter the relevant details</h3>
\&        </div>\*(Aq;
\&    }
\&    1;
.Ve
.PP
When a form is rendered, it will either loop through all of the sorted_fields \s-1OR\s0
loop through the fields and blocks listed in the 'render_list'. A render_list can
contain a mix of fields and blocks.
.PP
Note that you must be rendering with widgets to use block rendering.
.SS "Twitter Bootstrap 2.0 rendering"
.IX Subsection "Twitter Bootstrap 2.0 rendering"
The main component of Bootstrap rendering is HTML::FormHandler::Widget::Wrapper::Bootstrap.
It produces the standard Bootstrap-style \s-1HTML\s0 such as:
.PP
.Vb 6
\&    <div class="control\-group">
\&      <label class="control\-label" for="input01">Text input</label>
\&      <div class="controls">
\&        <input type="text" class="input\-xlarge" id="input01" name="input01" value="" />
\&      </div>
\&    </div>
.Ve
.PP
These are the standard 'control' blocks for Bootstrap vertical and horizontal forms.
You can apply this wrapper to all of your fields by setting the widget_wrapper in the form:
.PP
.Vb 1
\&   has \*(Aq+widget_wrapper\*(Aq => ( default => \*(AqBootstrap\*(Aq );
.Ve
.PP
There is also a sample \*(L"theme\*(R": HTML::FormHandler::Widget::Theme::Bootstrap. It sets
the widget_wrapper for you and provides a 'render_form_messages' method to render a
success/error messages section.
.PP
There are a couple of examples in the t/bootstrap directory of Bootstrap inline and search forms,
which don't use exactly the same kind of control \s-1HTML\s0.
.PP
You can always copy the existing wrapper and add your own features, with settings provided
by the 'tags' hashref.
.SS "Rendering themes"
.IX Subsection "Rendering themes"
Many of the flags and settings necessary for rendering can now be moved out into a role.
Whether you want to do that or not is a matter of style and preference. The advantage is
that it leaves the form class itself cleaner and easier to read. The disadvantage is
that your settings come from more different places.
.PP
Here's an example of a form rendering 'theme', taken from the t/bootstrap/basic.t test:
.PP
.Vb 2
\&    package MyApp::Form::Basic::Theme;
\&    use Moose::Role;
\&
\&    # make a wrapper around the form
\&    sub build_do_form_wrapper {1}
\&    # set the class for the form wrapper
\&    sub build_form_wrapper_class { [\*(Aqspan9\*(Aq] }
\&    # set the class for the form element
\&    sub build_form_element_class { [\*(Aqwell\*(Aq] }
\&    # set various rendering tags
\&    sub build_form_tags {
\&        {   wrapper_tag => \*(Aqdiv\*(Aq,
\&            before => qq{<div class="row"><div class="span3"><p>With v2.0, we have
\&               lighter and smarter defaults for form styles. No extra markup, just
\&               form controls.</p></div>\en},
\&            after => \*(Aq</div>\*(Aq,
\&        }
\&    }
\&
\&    # the settings in \*(Aqbuild_update_subfields\*(Aq are merged with the field
\&    # definitions before they are constructed
\&    sub build_update_subfields {{
\&       # all fields have a label but no wrapper
\&       all => { do_wrapper => 0, do_label => 1 },
\&       # set the element class, a placeholder in element_attr
\&       foo => { element_class => [\*(Aqspan3\*(Aq],
\&           element_attr => { placeholder => \*(AqType something…\*(Aq },
\&           tags => { after_element =>
\&              qq{\en<span class="help\-inline">Associated help text!</span>} } },
\&       bar => { option_label => \*(AqCheck me out\*(Aq,
\&          label_class => [\*(Aqcheckbox\*(Aq], do_label => 0 },
\&       submit_btn => { element_class => [\*(Aqbtn\*(Aq] },
\&    }}
.Ve
.PP
Note that the value 'all' key in the update_subfields hashref will be merged
into the attributes used when building all of the fields.
.SS "Rendering fields"
.IX Subsection "Rendering fields"
The default for most fields is a 'div' wrapper and a label. If you don't want
the wrapper, set \f(CW\*(C`do_wrapper => 0\*(C'\fR. If you don't want the label, set
\&\f(CW\*(C`do_label => 0\*(C'\fR.
.PP
Checkboxes are most complicated, in that the default
is to have two labels. The outer label, the one that's in the same place as the label
for other input elements, is set with \f(CW\*(C`label => \*(Aq...\*(Aq\*(C'\fR. The inner label,
which is the equivalent of the \f(CW\*(C`label => \*(Aq...\*(Aq\*(C'\fR in the options array used
for selects and checkbox groups, is set with \f(CW\*(C`option_label => \*(Aq...\*(Aq\*(C'\fR.
There are a number of other 'tags' to control the presentation. See
HTML::FormHandler::Widget::Field::Checkbox for more information, and
t/render/checkbox.t for examples.
.PP
Some fields by default do not render a label: Button, Submit, Reset, ButtonTag.
If you do want a label with these fields, you must set the 'do_label' flag to 1:
.PP
.Vb 1
\&   has_field \*(Aqfoo\*(Aq ( type => \*(AqButton\*(Aq, do_label => 1 );
.Ve
.PP
Select fields are also fairly complicated. They can be rendered with the
\&'Select', 'RadioGroup', and 'CheckboxGroup' widgets. Option groups are also
supported. See HTML::FormHandler::Field::Select;
.SS "Rendering labels"
.IX Subsection "Rendering labels"
A 'standard' label is built in the field if you don't supply one. The label
can be provided in the field definition:
.PP
.Vb 1
\&    has_field \*(Aqfoo\*(Aq => ( label => \*(AqMy Foo\*(Aq );
.Ve
.PP
You can also provide a method to 'build' the label:
.PP
.Vb 5
\&    has_field \*(Aqfoo\*(Aq => ( build_label_method => \e&build_label );
\&    sub build_label {
\&        my $self = shift; # field method
\&        return \*(Aq...\*(Aq;
\&    }
.Ve
.PP
And a method to 'wrap' the label (used by the Simple and Bootstrap wrappers):
.PP
.Vb 6
\&    has_field \*(Aqfoo\*(Aq => ( label => \*(AqMy Foo\*(Aq, wrap_label_method => \e&wrap_label );
\&    sub wrap_label {
\&        my ( $self, $label ) = @_;
\&        # or: my $label = $self\->label;
\&        return qq{<a href="...">$label</a>};
\&    }
.Ve
.PP
This is particularly useful for creating labels that have links or other \s-1HTML\s0.
The 'wrap_label_method' does no filtering or localization, so you must do that
yourself in the method if you need it.
.SS "Rendering filter"
.IX Subsection "Rendering filter"
The base field class has a 'render_filter' attribute which is a coderef used to
clean the values used to fill in the form for Render::Simple and the Widgets,
and for some of the labels..
The default filter changes quote, ampersand, <, and > to the equivalent html
entities. If you wish to use some other sort of filtering, you can use the
\&'render_filter' method in your form, or set a coderef on individual field
objects. A 'render_filter' function in your form will be used by all fields.
Setting it for a field will just be for that field.
.PP
.Vb 7
\&    sub render_filter {
\&        my $string = shift;
\&        $string =~ s/my/MY/g; # perform some kind of transformation
\&        return $string;
\&    }
\&    \-\- or \-\-
\&    has_field \*(Aqfoo\*(Aq => ( render_filter => sub { ... } );
.Ve
.PP
The filter is called in Render::Simple and in the widgets with
\&\f(CW\*(C`$self\->html_filter( $fif )\*(C'\fR or \f(CW\*(C`$field\->html_filter( $fif )\*(C'\fR.
.PP
If you want to turn off the filter for a particular field, you can set it
to a sub that just returns the value:
.PP
.Vb 1
\&    has_field \*(Aqbar\*(Aq => ( render_filter => sub { shift } );
.Ve
.PP
If you want a label that is unfiltered, see 'wrap_label_method'.
.SH "Special rendering pseudo-fields"
.IX Header "Special rendering pseudo-fields"
Also see HTML::FormHandler::Widget::Block. Blocks may be a better
solution than pseudo-fields (i.e. fields that aren't actual form
elements).
.PP
Various 'tags' used for rendering can also be used for similar
purposes.
.SS "NonEditable"
.IX Subsection "NonEditable"
Like a Bootstrap 'non_editable' field. Displays the field's value
as a span.
.PP
.Vb 1
\&    has_field \*(Aqnon_edit\*(Aq => ( type => \*(AqNonEditable\*(Aq, value => \*(AqThis is a Test\*(Aq );
.Ve
.SS "Display"
.IX Subsection "Display"
HTML::FormHandler::Field::Display
.PP
You can supply an \s-1HTML\s0 string to this field, to be displayed directly. There is no
\&'value' associated with this field; it's a field for rendering only. The \s-1HTML\s0
string can be built with a form or field method.
.PP
Blocks or tags will often be a better solution.
.SH "AUTHOR"
.IX Header "AUTHOR"
FormHandler Contributors \- see HTML::FormHandler
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2014 by Gerda Shank.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
