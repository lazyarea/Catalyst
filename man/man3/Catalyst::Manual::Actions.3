.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Catalyst::Manual::Actions 3"
.TH Catalyst::Manual::Actions 3 "2013-05-07" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::Manual::Actions \- Catalyst Reusable Actions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the manual describes the reusable action system in
Catalyst, how such actions work, descriptions of some existing ones, and
how to write your own.  Reusable actions are attributes on Catalyst
methods that allow you to decorate your method with functions running
before or after the method call.  This can be used to implement commonly
used action patterns, while still leaving you full freedom to customize
them.
.SH "USING ACTIONS"
.IX Header "USING ACTIONS"
This is pretty simple. Actions work just like the normal dispatch
attributes you are used to, like Local or Private:
.PP
.Vb 3
\&  sub Hello :Local :ActionClass(\*(AqSayBefore\*(Aq) { 
\&        $c\->res\->output( \*(AqHello \*(Aq.$c\->stash\->{what} );
\&  }
.Ve
.PP
In this example, we expect the SayBefore action to magically populate
stash with something relevant before \f(CW\*(C`Hello\*(C'\fR is run.  In the next
section we'll show you how to implement it. If you want it in a
namespace other than Catalyst::Action you can prefix the action name
with a '+', for instance '+Foo::SayBefore', or if you just want it under
your application namespace instead, use MyAction, like
MyAction('SayBefore').
.SH "WRITING YOUR OWN ACTIONS"
.IX Header "WRITING YOUR OWN ACTIONS"
Implementing the action itself is almost as easy. Just use
Catalyst::Action as a base class and decorate the \f(CW\*(C`execute\*(C'\fR call in
the Action class:
.PP
.Vb 3
\&  package Catalyst::Action::MyAction;
\&  use Moose;
\&  use namespace::autoclean;
\&  
\&  extends \*(AqCatalyst::Action\*(Aq;
\&
\&  before \*(Aqexecute\*(Aq => sub {
\&    my ( $self, $controller, $c, $test ) = @_;
\&    $c\->stash\->{what} = \*(Aqworld\*(Aq;
\&  };
\&
\&  after \*(Aqexecute\*(Aq => sub {
\&      my ( $self, $controller, $c, $test ) = @_;
\&      $c\->stash\->{foo} = \*(Aqbar\*(Aq;
\&  };
\&
\&  _\|_PACKAGE_\|_\->meta\->make_immutable;
.Ve
.PP
Pretty simple, huh?
.SH "ACTION ROLES"
.IX Header "ACTION ROLES"
You can only have one action class per action, which can be somewhat
inflexible.
.PP
The solution to this is to use Catalyst::Controller::ActionRole, which
would make the example above look like this:
.PP
.Vb 2
\&  package Catalyst::ActionRole::MyActionRole;
\&  use Moose::Role;
\&
\&  before \*(Aqexecute\*(Aq => sub {
\&    my ( $self, $controller, $c, $test ) = @_;
\&    $c\->stash\->{what} = \*(Aqworld\*(Aq;
\&  };
\&
\&  after \*(Aqexecute\*(Aq => sub {
\&      my ( $self, $controller, $c, $test ) = @_;
\&      $c\->stash\->{foo} = \*(Aqbar\*(Aq;
\&  };
\&  
\&  1;
.Ve
.PP
and this would be used in a controller like this:
.PP
.Vb 4
\&  package MyApp::Controller::Foo;
\&  use Moose;
\&  use namespace::autoclean;
\&  BEGIN { extends \*(AqCatalyst::Controller::ActionRole\*(Aq; }
\&
\&  sub foo : Does(\*(AqMyActionRole\*(Aq) {
\&      my ($self, $c) = @_;
\&  }
\&
\&  1;
.Ve
.SH "EXAMPLE ACTIONS"
.IX Header "EXAMPLE ACTIONS"
.SS "Catalyst::Action::RenderView"
.IX Subsection "Catalyst::Action::RenderView"
This is meant to decorate end actions. It's similar in operation to 
Catalyst::Plugin::DefaultEnd, but allows you to decide on an action
level rather than on an application level where it should be run.
.SS "Catalyst::Action::REST"
.IX Subsection "Catalyst::Action::REST"
Provides additional syntax for dispatching based upon the \s-1HTTP\s0 method
of the request.
.SH "EXAMPLE ACTIONROLES"
.IX Header "EXAMPLE ACTIONROLES"
.SS "Catalyst::ActionRole::ACL"
.IX Subsection "Catalyst::ActionRole::ACL"
Provides ACLs for role membership by decorating your actions.
.SH "AUTHORS"
.IX Header "AUTHORS"
Catalyst Contributors, see Catalyst.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software. You can redistribute it and/or modify it under
the same terms as Perl itself.
